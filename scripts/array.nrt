/* implemented as intrinsic
void* [](void*[] array, int ind)
{
}*/
/* array layout
type array
{
	void* data;
	int capacity;
	int size;
}*/


//proposed generics
type<T> array
{
	T& data
	int capacity
	int size
}



T& [](array<T>& arr, int i)
{
	printF(arr.data.x)
//	printF(arr.data.y)
	return __off(arr.data, i)
}

//problem: generic functions are contained in the module after the function they may be used in

//void &[1] typecast(__Array _arr)
void init(array<T>& _arr)
{
	_arr.data := alloc(16)
	_arr.capacity = 2
	_arr.size = 0
}

//ensures that the array has atleast space for _size
void reserve(array<T>& _arr, int _capacity)
{
	if(_capacity > _arr.capacity)
	{
		T& dat := _arr.data
		
		printI(_arr.capacity)
		_arr.capacity = 8 * _arr.capacity * 2 //growth factor, change to 1.5 when float -> int cast is enabled
		_arr.data := alloc(_capacity)
		
		int i = -1
		while(++i < _arr.size) { _arr[i] = __off(dat, i) }
		
		free(dat)
		
		_arr.capacity = _capacity
	}
}

void push_back(array<T>& _arr, T& _el)
{
//	printI(_arr.size)
	reserve(_arr, _arr.size+1)

//	_arr[_arr.size] = _el
	_arr.size = _arr.size + 1
}

/*
//append copys of all elements of _oth to _slf
__Array +=(__Array _slf, __Array _oth)
{
	int n = _slf.size
	expand(_slf, _slf.size + _oth.size)
	
	int i = -1
	while(++i < _oth.size)
	{
		_slf[i + n] = _oth[i]
	}
	
} */